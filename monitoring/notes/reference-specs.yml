Kubernetes Monitoring with VictoriaMetrics - Complete YAML Configuration
This document contains all the YAML configurations needed to implement a complete Kubernetes monitoring solution using VictoriaMetrics stack, based on the article series you provided.
1. Namespace Creation
yamlapiVersion: v1
kind: Namespace
metadata:
  name: monitoring
  labels:
    name: monitoring
2. VictoriaMetrics Operator Installation
Option A: Using Helm (Recommended)
bash# Add VictoriaMetrics Helm repository
helm repo add vm https://victoriametrics.github.io/helm-charts/
helm repo update

# Install the complete k8s monitoring stack
helm install victoria-metrics-k8s-stack vm/victoria-metrics-k8s-stack \
  --namespace monitoring \
  --create-namespace \
  -f values-k8s-stack.yaml
Option B: Using Manifests
yaml# victoria-metrics-operator.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vm-operator
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: vm-operator
  template:
    metadata:
      labels:
        app: vm-operator
    spec:
      serviceAccountName: vm-operator
      containers:
      - name: manager
        image: victoriametrics/operator:v0.54.1
        ports:
        - containerPort: 9443
          name: webhook-server
          protocol: TCP
        resources:
          limits:
            cpu: 120m
            memory: 320Mi
          requests:
            cpu: 80m
            memory: 120Mi
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vm-operator
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vm-operator
rules:
- apiGroups: [""]
  resources: ["nodes", "nodes/proxy", "services", "endpoints", "pods", "configmaps", "secrets"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
- apiGroups: ["apps"]
  resources: ["deployments", "statefulsets", "replicasets"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
- apiGroups: ["operator.victoriametrics.com"]
  resources: ["*"]
  verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vm-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vm-operator
subjects:
- kind: ServiceAccount
  name: vm-operator
  namespace: monitoring
3. VictoriaMetrics Cluster Configuration
yaml# vmcluster.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMCluster
metadata:
  name: vmcluster
  namespace: monitoring
spec:
  retentionPeriod: "14d"
  replicationFactor: 2
  vminsert:
    replicaCount: 2
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi
    extraArgs:
      maxLabelsPerTimeseries: "50"
  vmselect:
    replicaCount: 2
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi
    extraArgs:
      search.maxUniqueTimeseries: "300000"
      search.maxQueryDuration: "30m"
  vmstorage:
    replicaCount: 2
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 1000m
        memory: 2Gi
    storage:
      volumeClaimTemplate:
        spec:
          resources:
            requests:
              storage: 20Gi
          storageClassName: fast-ssd  # Adjust based on your storage class
    extraArgs:
      loggerLevel: "WARN"
      dedup.minScrapeInterval: "30s"
4. VMAgent Configuration for Metrics Collection
yaml# vmagent.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMAgent
metadata:
  name: vmagent
  namespace: monitoring
spec:
  serviceScrapeNamespaceSelector: {}
  podScrapeNamespaceSelector: {}
  probeNamespaceSelector: {}
  nodeSelector: {}
  replicaCount: 1
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi
  remoteWrite:
  - url: "http://vminsert-vmcluster.monitoring.svc.cluster.local:8480/insert/0/prometheus/"
  extraArgs:
    promscrape.streamParse: "true"
    promscrape.configCheckInterval: "30s"
  scrapeInterval: "30s"
  evaluationInterval: "30s"
  externalLabels:
    cluster: "k8s-cluster"
  selectAllByDefault: true
5. Service Monitors for Core Components
Kubernetes API Server
yaml# servicemonitor-apiserver.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMServiceScrape
metadata:
  name: kubernetes-apiserver
  namespace: monitoring
spec:
  jobLabel: component
  endpoints:
  - port: https
    interval: 30s
    scheme: https
    tlsConfig:
      caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
      serverName: kubernetes
      insecureSkipVerify: false
    bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
    relabelConfigs:
    - sourceLabels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
      action: keep
      regex: default;kubernetes;https
  namespaceSelector:
    matchNames:
    - default
  selector:
    matchLabels:
      component: apiserver
      provider: kubernetes
Kubelet and cAdvisor
yaml# servicemonitor-kubelet.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMNodeScrape
metadata:
  name: kubelet
  namespace: monitoring
spec:
  path: /metrics
  port: "10250"
  scheme: https
  interval: 30s
  tlsConfig:
    caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    insecureSkipVerify: true
  bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
  relabelConfigs:
  - action: labelmap
    regex: __meta_kubernetes_node_label_(.+)
---
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMNodeScrape
metadata:
  name: cadvisor
  namespace: monitoring
spec:
  path: /metrics/cadvisor
  port: "10250"
  scheme: https
  interval: 30s
  tlsConfig:
    caFile: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    insecureSkipVerify: true
  bearerTokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
  metricRelabelConfigs:
  - sourceLabels: [__name__]
    regex: 'container_cpu_(usage_seconds_total|cfs_throttled_seconds_total)|container_memory_(usage_bytes|working_set_bytes|cache|swap)|container_network_(receive_bytes_total|transmit_bytes_total)|container_fs_(usage_bytes|limit_bytes|reads_total|writes_total)'
    action: keep
kube-state-metrics
yaml# kube-state-metrics.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kube-state-metrics
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kube-state-metrics
  template:
    metadata:
      labels:
        app: kube-state-metrics
    spec:
      serviceAccountName: kube-state-metrics
      containers:
      - name: kube-state-metrics
        image: registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.10.0
        ports:
        - containerPort: 8080
          name: http-metrics
        - containerPort: 8081
          name: telemetry
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 5
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /
            port: 8081
          initialDelaySeconds: 5
          timeoutSeconds: 5
        resources:
          requests:
            cpu: 10m
            memory: 32Mi
          limits:
            cpu: 200m
            memory: 256Mi
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: kube-state-metrics
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kube-state-metrics
rules:
- apiGroups: [""]
  resources: ["nodes", "pods", "services", "resourcequotas", "replicationcontrollers", "limitranges", "persistentvolumeclaims", "persistentvolumes", "namespaces", "endpoints", "secrets", "configmaps"]
  verbs: ["list", "watch"]
- apiGroups: ["apps"]
  resources: ["statefulsets", "daemonsets", "deployments", "replicasets"]
  verbs: ["list", "watch"]
- apiGroups: ["batch"]
  resources: ["cronjobs", "jobs"]
  verbs: ["list", "watch"]
- apiGroups: ["autoscaling"]
  resources: ["horizontalpodautoscalers"]
  verbs: ["list", "watch"]
- apiGroups: ["networking.k8s.io"]
  resources: ["networkpolicies", "ingresses"]
  verbs: ["list", "watch"]
- apiGroups: ["policy"]
  resources: ["poddisruptionbudgets"]
  verbs: ["list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kube-state-metrics
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kube-state-metrics
subjects:
- kind: ServiceAccount
  name: kube-state-metrics
  namespace: monitoring
---
apiVersion: v1
kind: Service
metadata:
  name: kube-state-metrics
  namespace: monitoring
  labels:
    app: kube-state-metrics
spec:
  ports:
  - name: http-metrics
    port: 8080
    targetPort: http-metrics
    protocol: TCP
  - name: telemetry
    port: 8081
    targetPort: telemetry
    protocol: TCP
  selector:
    app: kube-state-metrics
---
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMServiceScrape
metadata:
  name: kube-state-metrics
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app: kube-state-metrics
  endpoints:
  - port: http-metrics
    interval: 30s
    path: /metrics
Node Exporter
yaml# node-exporter.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-exporter
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app: node-exporter
  template:
    metadata:
      labels:
        app: node-exporter
    spec:
      hostNetwork: true
      hostPID: true
      tolerations:
      - effect: NoSchedule
        operator: Exists
      - effect: NoExecute
        operator: Exists
      containers:
      - name: node-exporter
        image: prom/node-exporter:v1.6.1
        args:
        - --path.sysfs=/host/sys
        - --path.rootfs=/host/root
        - --no-collector.wifi
        - --no-collector.hwmon
        - --collector.filesystem.ignored-mount-points=^/(dev|proc|sys|var/lib/docker/.+|var/lib/kubelet/pods/.+)($|/)
        - --collector.netclass.ignored-devices=^(veth.*)$
        - --collector.netdev.device-exclude=^(veth.*)$
        ports:
        - containerPort: 9100
          protocol: TCP
        resources:
          limits:
            cpu: 250m
            memory: 180Mi
          requests:
            cpu: 102m
            memory: 180Mi
        volumeMounts:
        - mountPath: /host/sys
          name: sys
          readOnly: true
        - mountPath: /host/root
          mountPropagation: HostToContainer
          name: root
          readOnly: true
      volumes:
      - hostPath:
          path: /sys
        name: sys
      - hostPath:
          path: /
        name: root
---
apiVersion: v1
kind: Service
metadata:
  name: node-exporter
  namespace: monitoring
  labels:
    app: node-exporter
spec:
  ports:
  - name: http-metrics
    port: 9100
    targetPort: 9100
    protocol: TCP
  selector:
    app: node-exporter
---
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMServiceScrape
metadata:
  name: node-exporter
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app: node-exporter
  endpoints:
  - port: http-metrics
    interval: 30s
    path: /metrics
6. VMAlert for Alerting
yaml# vmalert.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMAlert
metadata:
  name: vmalert
  namespace: monitoring
spec:
  replicaCount: 1
  datasource:
    url: "http://vmselect-vmcluster.monitoring.svc.cluster.local:8481/select/0/prometheus"
  notifier:
    url: "http://alertmanager.monitoring.svc.cluster.local:9093"
  remoteWrite:
    url: "http://vminsert-vmcluster.monitoring.svc.cluster.local:8480/insert/0/prometheus/"
  remoteRead:
    url: "http://vmselect-vmcluster.monitoring.svc.cluster.local:8481/select/0/prometheus"
  evaluationInterval: "30s"
  ruleNamespaceSelector: {}
  selectAllByDefault: true
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi
7. Alertmanager Configuration
yaml# alertmanager.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: alertmanager-config
  namespace: monitoring
data:
  config.yml: |
    global:
      smtp_smarthost: 'localhost:587'
      smtp_from: 'alertmanager@example.org'
    route:
      group_by: ['alertname']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 1h
      receiver: 'web.hook'
    receivers:
    - name: 'web.hook'
      webhook_configs:
      - url: 'http://127.0.0.1:5001/'
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: alertmanager
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: alertmanager
  template:
    metadata:
      labels:
        app: alertmanager
    spec:
      containers:
      - name: alertmanager
        image: prom/alertmanager:v0.25.0
        args:
        - --config.file=/etc/alertmanager/config.yml
        - --storage.path=/alertmanager
        - --web.external-url=http://localhost:9093
        ports:
        - containerPort: 9093
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        volumeMounts:
        - name: config-volume
          mountPath: /etc/alertmanager
        - name: storage-volume
          mountPath: /alertmanager
      volumes:
      - name: config-volume
        configMap:
          name: alertmanager-config
      - name: storage-volume
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: alertmanager
  namespace: monitoring
spec:
  ports:
  - name: http
    port: 9093
    targetPort: 9093
  selector:
    app: alertmanager
8. Basic Alert Rules
yaml# alert-rules.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMRule
metadata:
  name: kubernetes-alerts
  namespace: monitoring
spec:
  groups:
  - name: kubernetes-alerts
    rules:
    - alert: KubernetesNodeReady
      expr: kube_node_status_condition{condition="Ready",status="true"} == 0
      for: 10m
      labels:
        severity: critical
      annotations:
        summary: Kubernetes Node ready (instance {{ $labels.instance }})
        description: "Node {{ $labels.node }} has been unready for a long time"

    - alert: KubernetesMemoryPressure
      expr: kube_node_status_condition{condition="MemoryPressure",status="true"} == 1
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: Kubernetes memory pressure (instance {{ $labels.instance }})
        description: "Node {{ $labels.node }} has MemoryPressure condition"

    - alert: KubernetesDiskPressure
      expr: kube_node_status_condition{condition="DiskPressure",status="true"} == 1
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: Kubernetes disk pressure (instance {{ $labels.instance }})
        description: "Node {{ $labels.node }} has DiskPressure condition"

    - alert: KubernetesOutOfDisk
      expr: kube_node_status_condition{condition="OutOfDisk",status="true"} == 1
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: Kubernetes out of disk (instance {{ $labels.instance }})
        description: "Node {{ $labels.node }} has OutOfDisk condition"

    - alert: KubernetesPodCrashLooping
      expr: increase(kube_pod_container_status_restarts_total[1m]) > 3
      for: 2m
      labels:
        severity: warning
      annotations:
        summary: Kubernetes pod crash looping (instance {{ $labels.instance }})
        description: "Pod {{ $labels.pod }} is crash looping"

    - alert: KubernetesPodNotReady
      expr: kube_pod_status_phase{phase=~"Pending|Unknown"} > 0
      for: 15m
      labels:
        severity: warning
      annotations:
        summary: Kubernetes Pod not ready (instance {{ $labels.instance }})
        description: "Pod {{ $labels.pod }} has been in a non-ready state for longer than 15 minutes."
9. Grafana Installation and Configuration
yaml# grafana.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-datasources
  namespace: monitoring
data:
  prometheus.yaml: |-
    {
        "apiVersion": 1,
        "datasources": [
            {
               "access":"proxy",
                "editable": true,
                "name": "VictoriaMetrics",
                "orgId": 1,
                "type": "prometheus",
                "url": "http://vmselect-vmcluster.monitoring.svc.cluster.local:8481/select/0/prometheus/",
                "version": 1,
                "isDefault": true
            }
        ]
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      securityContext:
        fsGroup: 472
        supplementalGroups:
          - 0
      containers:
        - name: grafana
          image: grafana/grafana:10.1.0
          ports:
            - containerPort: 3000
              name: http-grafana
              protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /robots.txt
              port: 3000
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 30
            successThreshold: 1
            timeoutSeconds: 2
          livenessProbe:
            failureThreshold: 3
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            tcpSocket:
              port: 3000
            timeoutSeconds: 1
          resources:
            requests:
              cpu: 250m
              memory: 750Mi
            limits:
              cpu: 500m
              memory: 1Gi
          volumeMounts:
            - mountPath: /var/lib/grafana
              name: grafana-pv
            - mountPath: /etc/grafana/provisioning/datasources
              name: grafana-datasources
              readOnly: false
          env:
            - name: GF_SECURITY_ADMIN_USER
              value: admin
            - name: GF_SECURITY_ADMIN_PASSWORD
              value: admin123  # Change this password!
      volumes:
        - name: grafana-pv
          emptyDir: {}
        - name: grafana-datasources
          configMap:
              defaultMode: 420
              name: grafana-datasources
---
apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: monitoring
spec:
  ports:
    - port: 3000
      protocol: TCP
      targetPort: http-grafana
  selector:
    app: grafana
  sessionAffinity: None
  type: ClusterIP
10. VictoriaLogs for Log Management
yaml# victorialogs.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VLogs
metadata:
  name: vlogs
  namespace: monitoring
spec:
  retentionPeriod: "14d"
  replicaCount: 1
  resources:
    requests:
      cpu: 200m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 2Gi
  storage:
    volumeClaimTemplate:
      spec:
        resources:
          requests:
            storage: 20Gi
        storageClassName: fast-ssd
---
apiVersion: operator.victoriametrics.com/v1beta1
kind: VLAgent
metadata:
  name: vlagent
  namespace: monitoring
spec:
  config:
    - inputConfig: |
        inputs:
          - name: kubernetes
            type: kubernetes
            kubernetes:
              include_pod_metadata: true
              include_namespace_metadata: true
    - outputConfig: |
        outputs:
          - name: vlogs
            type: victorialogs
            victorialogs:
              url: http://vlogs-victorialogs.monitoring.svc.cluster.local:9428/insert/jsonline
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi
11. Helm Values File for K8s Stack (Alternative Installation)
yaml# values-k8s-stack.yaml
vmsingle:
  enabled: false

vmcluster:
  enabled: true
  spec:
    replicationFactor: 2
    retentionPeriod: "14d"
    vmselect:
      replicaCount: 2
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
        limits:
          cpu: 500m
          memory: 512Mi
    vminsert:
      replicaCount: 2
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
        limits:
          cpu: 500m
          memory: 512Mi
    vmstorage:
      replicaCount: 2
      resources:
        requests:
          cpu: 200m
          memory: 512Mi
        limits:
          cpu: 1000m
          memory: 2Gi
      storage:
        volumeClaimTemplate:
          spec:
            resources:
              requests:
                storage: 20Gi

vmagent:
  enabled: true
  spec:
    selectAllByDefault: true
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi

vmalert:
  enabled: true
  spec:
    selectAllByDefault: true
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi

alertmanager:
  enabled: true
  spec:
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi

grafana:
  enabled: true
  adminPassword: "admin123"  # Change this!
  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
      - name: VictoriaMetrics
        type: prometheus
        url: http://vmselect-vmcluster-victoria-metrics-k8s-stack:8481/select/0/prometheus/
        access: proxy
        isDefault: true

nodeExporter:
  enabled: true

kubeStateMetrics:
  enabled: true

prometheusOperatorCrds:
  enabled: false

defaultRules:
  create: true
  rules:
    etcd: false
    k8s: true
    kubeApiserver: true
    kubeApiserverAvailability: true
    kubeApiserverSlos: true
    kubelet: true
    kubeProxy: false
    kubePrometheusGeneral: true
    kubePrometheusNodeRecording: true
    kubernetesApps: true
    kubernetesResources: true
    kubernetesStorage: true
    kubernetesSystem: true
    node: true
Installation Steps

Create the namespace:
bashkubectl apply -f - <<EOF
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
EOF

Install using Helm (Recommended):
bashhelm repo add vm https://victoriametrics.github.io/helm-charts/
helm repo update
helm install victoria-metrics-k8s-stack vm/victoria-metrics-k8s-stack \
  --namespace monitoring \
  --create-namespace \
  -f values-k8s-stack.yaml

Or install using individual manifests:
bashkubectl apply -f victoria-metrics-operator.yaml
kubectl apply -f vmcluster.yaml
kubectl apply -f vmagent.yaml
kubectl apply -f servicemonitor-apiserver.yaml
kubectl apply -f servicemonitor-kubelet.yaml
kubectl apply -f kube-state-metrics.yaml
kubectl apply -f node-exporter.yaml
kubectl apply -f vmalert.yaml
kubectl apply -f alertmanager.yaml
kubectl apply -f alert-rules.yaml
kubectl apply -f grafana.yaml
kubectl apply -f victorialogs.yaml

Access Grafana:
bashkubectl port-forward -n monitoring svc/grafana 3000:3000
Then open http://localhost:3000 (admin/admin123)
Access VictoriaMetrics UI:
bashkubectl port-forward -n monitoring svc/vmselect-vmcluster 8481:8481
Then open http://localhost:8481

12. Additional ServiceMonitors for Common Applications
Ingress Controller (NGINX)
yaml# servicemonitor-nginx-ingress.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMServiceScrape
metadata:
  name: nginx-ingress-controller
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: ingress-nginx
      app.kubernetes.io/component: controller
  namespaceSelector:
    matchNames:
    - ingress-nginx
  endpoints:
  - port: prometheus
    interval: 30s
    path: /metrics
CoreDNS
yaml# servicemonitor-coredns.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMServiceScrape
metadata:
  name: coredns
  namespace: monitoring
spec:
  selector:
    matchLabels:
      k8s-app: kube-dns
  namespaceSelector:
    matchNames:
    - kube-system
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
etcd (for Talos/kubeadm clusters)
yaml# servicemonitor-etcd.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMServiceScrape
metadata:
  name: etcd
  namespace: monitoring
spec:
  selector:
    matchLabels:
      component: etcd
  namespaceSelector:
    matchNames:
    - kube-system
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
    scheme: https
    tlsConfig:
      caFile: /etc/ssl/etcd/ssl/ca.pem
      certFile: /etc/ssl/etcd/ssl/node-etcd.pem
      keyFile: /etc/ssl/etcd/ssl/node-etcd-key.pem
      serverName: etcd
13. Prometheus Recording Rules
yaml# recording-rules.yaml
apiVersion: operator.victoriametrics.com/v1beta1
kind: VMRule
metadata:
  name: kubernetes-recording-rules
  namespace: monitoring
spec:
  groups:
  - name: kubernetes-recording-rules
    interval: 30s
    rules:
    - record: cluster:namespace:pod_memory:active:kube_pod_container_resource_requests
      expr: |
        kube_pod_container_resource_requests{resource="memory",job="kube-state-metrics"}
        * on (namespace, pod, cluster)
        group_left() max by (namespace, pod, cluster) (
          (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
        )
    
    - record: cluster:namespace:pod_cpu:active:kube_pod_container_resource_requests
      expr: |
        kube_pod_container_resource_requests{resource="cpu",job="kube-state-metrics"}
        * on (namespace, pod, cluster)
        group_left() max by (namespace, pod, cluster) (
          (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
        )
    
    - record: cluster:namespace:pod_memory:active:kube_pod_container_resource_limits
      expr: |
        kube_pod_container_resource_limits{resource="memory",job="kube-state-metrics"}
        * on (namespace, pod, cluster)
        group_left() max by (namespace, pod, cluster) (
          (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
        )
    
    - record: cluster:namespace:pod_cpu:active:kube_pod_container_resource_limits
      expr: |
        kube_pod_container_resource_limits{resource="cpu",job="kube-state-metrics"}
        * on (namespace, pod, cluster)
        group_left() max by (namespace, pod, cluster) (
          (kube_pod_status_phase{phase=~"Pending|Running"} == 1)
        )
    
    - record: cluster:node_cpu:ratio_rate5m
      expr: |
        sum(rate(container_cpu_usage_seconds_total{job="kubelet", metrics_path="/metrics/cadvisor", image!="", container!="POD"}[5m])) by (cluster, node)
        /
        max by (cluster, node) (
          kube_node_status_allocatable{resource="cpu",job="kube-state-metrics"}
        )
14. Log Collection for VictoriaLogs
Fluent Bit Configuration
yaml# fluentbit-victorialogs.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: monitoring
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         1
        Log_Level     info
        Daemon        off
        Parsers_File  parsers.conf
        HTTP_Server   On
        HTTP_Listen   0.0.0.0
        HTTP_Port     2020

    [INPUT]
        Name              tail
        Path              /var/log/containers/*.log
        multiline.parser  docker, cri
        Tag               kube.*
        Mem_Buf_Limit     50MB
        Skip_Long_Lines   On

    [INPUT]
        Name systemd
        Tag  host.*
        Systemd_Filter _SYSTEMD_UNIT=kubelet.service
        Read_From_Tail On

    [FILTER]
        Name kubernetes
        Match kube.*
        Merge_Log On
        Keep_Log Off
        K8S-Logging.Parser On
        K8S-Logging.Exclude On

    [OUTPUT]
        Name http
        Match *
        Host vlogs-victorialogs.monitoring.svc.cluster.local
        Port 9428
        URI /insert/jsonline
        Format json
        Json_date_key timestamp
        Json_date_format iso8601

  parsers.conf: |
    [PARSER]
        Name   apache
        Format regex
        Regex  ^(?<host>[^ ]*) [^ ]* (?<user>[^ ]*) \[(?<time>[^\]]*)\] "(?<method>\S+)(?: +(?<path>[^\"]*?)(?: +\S*)?)?" (?<code>[^ ]*) (?<size>[^ ]*)(?: "(?<referer>[^\"]*)" "(?<agent>[^\"]*)")?$
        Time_Key time
        Time_Format %d/%b/%Y:%H:%M:%S %z

    [PARSER]
        Name   apache2
        Format regex
        Regex  ^(?<host>[^ ]*) [^ ]* (?<user>[^ ]*) \[(?<time>[^\]]*)\] "(?<method>\S+)(?: +(?<path>[^ ]*) +\S*)?" (?<code>[^ ]*) (?<size>[^ ]*)(?: "(?<referer>[^\"]*)" "(?<agent>[^\"]*)")?$
        Time_Key time
        Time_Format %d/%b/%Y:%H:%M:%S %z

    [PARSER]
        Name   apache_error
        Format regex
        Regex  ^\[[^ ]* (?<time>[^\]]*)\] \[(?<level>[^\]]*)\](?: \[pid (?<pid>[^\]]*)\])?( \[client (?<client>[^\]]*)\])? (?<message>.*)$

    [PARSER]
        Name   nginx
        Format regex
        Regex ^(?<remote>[^ ]*) (?<host>[^ ]*) (?<user>[^ ]*) \[(?<time>[^\]]*)\] "(?<method>\S+)(?: +(?<path>[^\"]*?)(?: +\S*)?)?" (?<code>[^ ]*) (?<size>[^ ]*)(?: "(?<referer>[^\"]*)" "(?<agent>[^\"]*)")?$
        Time_Key time
        Time_Format %d/%b/%Y:%H:%M:%S %z

    [PARSER]
        Name   json
        Format json
        Time_Key time
        Time_Format %d/%b/%Y:%H:%M:%S %z

    [PARSER]
        Name        docker
        Format      json
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L
        Time_Keep   On

    [PARSER]
        Name cri
        Format regex
        Regex ^(?<time>[^ ]+) (?<stream>stdout|stderr) (?<logtag>[^ ]*) (?<message>.*)$
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L%z

    [PARSER]
        Name        syslog
        Format      regex
        Regex       ^\<(?<pri>[0-9]+)\>(?<time>[^ ]* {1,2}[^ ]* [^ ]*) (?<host>[^ ]*) (?<ident>[a-zA-Z0-9_\/\.\-]*)(?:\[(?<pid>[0-9]+)\])?(?:[^\:]*\:)? *(?<message>.*)$
        Time_Key    time
        Time_Format %b %d %H:%M:%S

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluent-bit
  namespace: monitoring
  labels:
    k8s-app: fluent-bit-logging
    version: v1
    kubernetes.io/cluster-service: "true"
spec:
  selector:
    matchLabels:
      k8s-app: fluent-bit-logging
  template:
    metadata:
      labels:
        k8s-app: fluent-bit-logging
        version: v1
        kubernetes.io/cluster-service: "true"
    spec:
      serviceAccount: fluent-bit
      serviceAccountName: fluent-bit
      tolerations:
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      - operator: "Exists"
        effect: "NoExecute"
      - operator: "Exists"
        effect: "NoSchedule"
      containers:
      - name: fluent-bit
        image: fluent/fluent-bit:2.1.8
        imagePullPolicy: Always
        ports:
          - containerPort: 2020
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: fluent-bit-config
          mountPath: /fluent-bit/etc/
        - name: mnt
          mountPath: /mnt
          readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: fluent-bit-config
        configMap:
          name: fluent-bit-config
      - name: mnt
        hostPath:
          path: /mnt
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: fluent-bit
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: fluent-bit-read
rules:
- apiGroups: [""]
  resources:
  - namespaces
  - pods
  - pods/logs
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: fluent-bit-read
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: fluent-bit-read
subjects:
- kind: ServiceAccount
  name: fluent-bit
  namespace: monitoring
15. Network Policies (Optional Security)
yaml# network-policies.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: monitoring-network-policy
  namespace: monitoring
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    - namespaceSelector:
        matchLabels:
          name: kube-system
  - from: []
    ports:
    - protocol: TCP
      port: 3000  # Grafana
    - protocol: TCP
      port: 9093  # Alertmanager
    - protocol: TCP
      port: 8429  # VMAgent
    - protocol: TCP
      port: 8481  # VMSelect
  egress:
  - {}  # Allow all egress traffic
16. Storage Classes (Example)
yaml# storage-classes.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: kubernetes.io/gce-pd  # Change based on your cloud provider
parameters:
  type: pd-ssd
  zones: us-central1-a,us-central1-b
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
---
# For AWS EKS
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd-aws
provisioner: ebs.csi.aws.com
parameters:
  type: gp3
  iops: "3000"
  throughput: "125"
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
---
# For Azure AKS
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd-azure
provisioner: disk.csi.azure.com
parameters:
  storageaccounttype: Premium_LRS
  kind: Managed
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
17. Backup Configuration for VictoriaMetrics
yaml# vmbackup.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: victoriametrics-backup
  namespace: monitoring
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: vmbackup
            image: victoriametrics/vmbackup:v1.93.4
            args:
            - -storageDataPath=/storage
            - -dst=s3://your-backup-bucket/vm-backups
            - -credsFilePath=/etc/credentials/credentials
            env:
            - name: AWS_REGION
              value: "us-west-2"
            volumeMounts:
            - name: storage
              mountPath: /storage
            - name: credentials
              mountPath: /etc/credentials
              readOnly: true
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 500m
                memory: 512Mi
          volumes:
          - name: storage
            persistentVolumeClaim:
              claimName: vmstorage-vmcluster-0  # Adjust based on your PVC names
          - name: credentials
            secret:
              secretName: backup-credentials
          restartPolicy: OnFailure
---
apiVersion: v1
kind: Secret
metadata:
  name: backup-credentials
  namespace: monitoring
type: Opaque
data:
  credentials: |  # Base64 encoded AWS credentials
    W2RlZmF1bHRdCmF3c19hY2Nlc3Nfa2V5X2lkID0gWU9VUl9BQ0NFU1NfS0VZCmF3c19zZWNyZXRfYWNjZXNzX2tleSA9IFlPVVJfU0VDUkVUX0tFWQ==
Quick Installation Script
bash#!/bin/bash
# install-monitoring.sh

set -e

NAMESPACE="monitoring"
HELM_RELEASE="victoria-metrics-k8s-stack"

echo "Installing VictoriaMetrics Kubernetes monitoring stack..."

# Add Helm repository
helm repo add vm https://victoriametrics.github.io/helm-charts/
helm repo update

# Create namespace
kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

# Install the stack
helm upgrade --install $HELM_RELEASE vm/victoria-metrics-k8s-stack \
  --namespace $NAMESPACE \
  --set vmcluster.enabled=true \
  --set vmsingle.enabled=false \
  --set grafana.enabled=true \
  --set grafana.adminPassword="admin123" \
  --set alertmanager.enabled=true \
  --set vmalert.enabled=true \
  --set vmagent.enabled=true \
  --set nodeExporter.enabled=true \
  --set kubeStateMetrics.enabled=true \
  --set defaultRules.create=true \
  --wait

echo "Installation complete!"
echo ""
echo "Access Grafana:"
echo "kubectl port-forward -n $NAMESPACE svc/grafana 3000:3000"
echo "Then open http://localhost:3000 (admin/admin123)"
echo ""
echo "Access VictoriaMetrics:"
echo "kubectl port-forward -n $NAMESPACE svc/vmselect-$HELM_RELEASE 8481:8481"
echo "Then open http://localhost:8481"
Troubleshooting Commands
bash# Check all pods in monitoring namespace
kubectl get pods -n monitoring

# Check VMCluster status
kubectl get vmcluster -n monitoring

# Check VMAgent status
kubectl get vmagent -n monitoring

# Check logs
kubectl logs -n monitoring -l app.kubernetes.io/name=vmagent
kubectl logs -n monitoring -l app.kubernetes.io/name=vmselect
kubectl logs -n monitoring -l app.kubernetes.io/name=vminsert
kubectl logs -n monitoring -l app.kubernetes.io/name=vmstorage

# Check service endpoints
kubectl get endpoints -n monitoring

# Port forward to access services
kubectl port-forward -n monitoring svc/grafana 3000:3000
kubectl port-forward -n monitoring svc/vmselect-vmcluster 8481:8481
kubectl port-forward -n monitoring svc/alertmanager 9093:9093
This comprehensive configuration provides a complete Kubernetes monitoring solution using VictoriaMetrics, including metrics collection, alerting, visualization with Grafana, and log management with VictoriaLogs. Adjust the resource limits, storage classes, and configurations based on your specific cluster requirements.